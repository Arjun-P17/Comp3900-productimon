"""
Calls improbable's ts-protoc-gen and get rid of Typescript files to generate
commonjs modules. We are not using Google's official build because it's too
hard to integrate jscompiler (closure) with react and webpack.

This rule was inspired by rules_closure's implementation of closure_proto_library
and rules_typescript_proto's implementation of typescript_proto_library, both under
Apache 2.0 license.
"""

load("@build_bazel_rules_nodejs//:providers.bzl", "JSNamedModuleInfo")
load("@rules_proto//proto:defs.bzl", "ProtoInfo")

CommonjsProtoLibraryAspect = provider(
    fields = {
        "deps_es5": "The transitive ES5 JS dependencies",
        "es5_outputs": "The ES5 JS files produced directly from the src protos",
    },
)

def _proto_path(proto):
    """
    The proto path is not really a file path
    It's the path to the proto that was seen when the descriptor file was generated.
    """
    path = proto.path
    root = proto.root.path
    ws = proto.owner.workspace_root
    if path.startswith(root):
        path = path[len(root):]
    if path.startswith("/"):
        path = path[1:]
    if path.startswith(ws):
        path = path[len(ws):]
    if path.startswith("/"):
        path = path[1:]
    return path

def _get_protoc_inputs(target, ctx):
    inputs = []
    inputs += target[ProtoInfo].direct_sources
    inputs += target[ProtoInfo].transitive_descriptor_sets.to_list()
    return inputs

def _get_input_proto_names(target):
    """
    Builds a string containing all of the input proto file names separated by spaces.
    """
    proto_inputs = []
    for src in target[ProtoInfo].direct_sources:
        if src.extension != "proto":
            fail("Input must be a proto file")
        normalized_file = _proto_path(src)
        proto_inputs.append(normalized_file)
    return " ".join(proto_inputs)

def _build_protoc_command(target, ctx):
    protoc_command = ctx.executable._protoc.path

    protoc_command += " --plugin=protoc-gen-ts=$PWD/" + ctx.executable._ts_protoc_gen.path

    protoc_output_dir = ctx.var["BINDIR"]
    protoc_command += " --ts_out=service=grpc-web:" + protoc_output_dir
    protoc_command += " --js_out=import_style=commonjs,binary:" + protoc_output_dir

    descriptor_sets_paths = [desc.path for desc in target[ProtoInfo].transitive_descriptor_sets.to_list()]
    protoc_command += " \"--descriptor_set_in=" + ctx.host_configuration.host_path_separator.join(descriptor_sets_paths) + "\""

    protoc_command += " " + _get_input_proto_names(target)

    return protoc_command

def _get_outputs(target, ctx):
    """
    Calculates all of the files that will be generated by the aspect.
    """
    js_outputs = []
    for src in target[ProtoInfo].direct_sources:
        file_name = src.basename[:-len(src.extension) - 1]
        for f in ["_pb", "_pb_service"]:
            full_name = file_name + f
            output = ctx.actions.declare_file(full_name + ".js")
            js_outputs.append(output)

    return js_outputs

def commonjs_proto_library_aspect_(target, ctx):
    """
    A bazel aspect that is applied on every proto_library rule on the transitive set of dependencies
    of a commonjs_proto_library rule.
    Handles running protoc to produce the generated JS files.
    """

    js_outputs = _get_outputs(target, ctx)

    command = _build_protoc_command(target, ctx)

    tools = []
    tools.extend(ctx.files._protoc)
    tools.extend(ctx.files._ts_protoc_gen)

    ctx.actions.run_shell(
        inputs = depset(_get_protoc_inputs(target, ctx)),
        outputs = js_outputs,
        progress_message = "Creating commonjs pb files %s" % ctx.label,
        command = command,
        use_default_shell_env = True,
        tools = depset(tools),
    )

    es5_outputs = depset(js_outputs)
    deps_es5 = []

    for dep in ctx.rule.attr.deps:
        aspect_data = dep[CommonjsProtoLibraryAspect]
        deps_es5.append(aspect_data.es5_outputs)
        deps_es5.append(aspect_data.deps_es5)

    return [CommonjsProtoLibraryAspect(
        es5_outputs = es5_outputs,
        deps_es5 = depset(transitive = deps_es5),
    )]

commonjs_proto_library_aspect = aspect(
    implementation = commonjs_proto_library_aspect_,
    attr_aspects = ["deps"],
    attrs = {
        "_protoc": attr.label(
            allow_single_file = True,
            executable = True,
            cfg = "host",
            default = Label("@com_google_protobuf//:protoc"),
        ),
        "_ts_protoc_gen": attr.label(
            allow_files = True,
            executable = True,
            cfg = "host",
            default = Label("@npm//ts-protoc-gen/bin:protoc-gen-ts"),
        ),
    },
)

def _commonjs_proto_library_impl(ctx):
    """
    Handles converting the aspect output into a provider
    """
    aspect_data = ctx.attr.proto[CommonjsProtoLibraryAspect]
    es5_outputs = aspect_data.es5_outputs
    outputs = depset(transitive = [es5_outputs])

    es5_srcs = depset(transitive = [es5_outputs, aspect_data.deps_es5])
    return struct(
        providers = [
            DefaultInfo(files = outputs),
            JSNamedModuleInfo(
                direct_sources = es5_srcs,
                sources = es5_srcs,
            ),
        ],
    )

commonjs_proto_library = rule(
    attrs = {
        "proto": attr.label(
            mandatory = True,
            allow_single_file = True,
            providers = [ProtoInfo],
            aspects = [commonjs_proto_library_aspect],
        ),
        "_protoc": attr.label(
            allow_single_file = True,
            executable = True,
            cfg = "host",
            default = Label("@com_google_protobuf//:protoc"),
        ),
        "_ts_protoc_gen": attr.label(
            allow_files = True,
            executable = True,
            cfg = "host",
            default = Label("@npm//ts-protoc-gen/bin:protoc-gen-ts"),
        ),
    },
    implementation = _commonjs_proto_library_impl,
)
